<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Choose your own Refactoring Adventure | a workshop at SassConf 2014 by Elyse Holladay & Jina Bolton</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/elyse.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/tomorrowlight.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Choose your own Refactoring Adventure</h1>
					<h5>A workshop at SassConf 2014</h5>
					<h6>by Elyse Holladay &amp; Jina Bolton</h6>
				</section>

				<!-- un/comment me to see type styles for reference! -->
				<section>
					<h1>Header</h1>
					<h2>Subhead or big quote</h2>
					<h3>Copy Headline</h3>
					<h4>Subhead</h4>
					<h5>Big copy</h5>
					<h6>Meta</h6>
					<p>Paragraph copy</p>
				</section>

				<!-- un/comment me to see colors for reference! -->
				<section data-state="white">
					<div class="color-sample-fuschia">$fuschia</div>
					<div class="color-sample-purple">$purple</div>
					<div class="color-sample-blue">$blue</div>
					<div class="color-sample-turquoise">$turquoise</div>
					<div class="color-sample-green">$green</div>
					<div class="color-sample-orange">$orange</div>
					<div class="color-sample-black">$black</div>
					<div class="color-sample-grey">$grey</div>
				</section>

				<section data-state="elyse">
					<h2>@elyseholladay</h2>
					<h6>Dev/Designer, Instructor, MakerSquare</h6>
				</section>

				<section data-state="jina">
					<h2>@jina</h2>
					<h6>Senior Product Designer, Salesforce</h6>
				</section>

				<section>
					<h3><a href="http://bit.ly/cya-refactoring">http://bit.ly/cya-refactoring</a></h3>
					<h6>Mini Questionnaire!</h6>
					<aside class="notes">
						<p>We just want to get an idea of where you're at before we begin. Nothing's required but any information you're willing to share helps us tailor this adventure to you!</p>
						<p>[give about 5-10]</p>
					</aside>
				</section>

				<section>
					<div class="survey-responses">
						<h6>My biggest issue(s) or concern(s) with my codebase is...</h6>
						<div><b>10</b>&nbsp;&nbsp;&nbsp;getting my team to agree</div>
						<div><b>5</b>&nbsp;&nbsp;&nbsp;issues with consistency of visual styles</div>
						<div><b>1</b>&nbsp;&nbsp;&nbsp;responsive code or browser-compliancy</div>
						<div><b>18</b>&nbsp;&nbsp;&nbsp;documentation</div>
						<div><b>4</b>&nbsp;&nbsp;&nbsp;how to best install/set up Sass</div>
						<!-- <ol>
							<li>getting my team to agree on a system/refactoring/using Sass at all</li>
							<li>how to best install/set up Sass in my project</li>
							<li>issues with consistency of visual styles, variables, etc</li>
							<li>specificity and naming problems in my HTML/CSS</li>
							<li>creating or editing modules</li>
							<li>importing, file size, confusing framework/vendor CSS</li>
							<li>responsive code or browser-compliancy</li>
							<li>I want one of these style guide things everyone is talking about</li>
							<li>organization and architecture</li>
							<li>documentation or testing</li>
						</ol> -->
					</div>
					<aside class="notes">
						<p>If we are lucky we can make a "stats" slide and put in some basic #s about the survey responses!</p>
					</aside>
				</section>


				<section data-state="refactoring">
					<section>
						<h4>&#8220;I always code perfectly the first time!&#8221;</h4>
						<h6>—Some Liar</h6>
						<aside class="notes">
							<p></p>
						</aside>
					</section>

					<section>
						<h2>Clarity &middot; Maintainability &middot; Efficiency &middot; DRY</h2>
						<aside class="notes">
							<p>We generally aim for a few standards in our code: clarity, maintainability, efficiency, and DRYness.</p>
							<p>We want our CSS to be clear, easy to read, easy to maintain; efficient to debug and to write, and to be DRY. Refactoring should improve upon one of those goals, if not all of them at once.</p>
							<p>For example: if your CSS (sass or not!) matches your markup too much, you want to remove or consolidate your nesting or chained classes: refactor. If it may be cleaner and easier to use placeholder extend for a class you aren't using in HTML: refactor. If you have a bunch of classnames that should be a group but aren't: refactor.</p>
						</aside>
					</section>

					<section>
						<h1>Clarity</h1>
						<p>Code should be clear, well-commented, and <br/>follow consistent rules. A developer new to <br/>the project should be able to understand it.</p>
					</section>

					<section>
						<h1>Maintainability</h1>
						<p>Code should be easy to update & maintain, <br/>not requiring hacks or over-specific styles. <br/>It should be clear where files and styles belong.</p>
					</section>

					<section>
						<h1>Efficiency</h1>
						<p>It should be easy for a developer to find <br/>where styles live, write new styles, fix bugs, <br/>or find documentation and instructions.</p>
					</section>

					<section>
						<h1>DRY</h1>
						<p>Don't repeat yourself! Code should be <br/>reusable, have efficient selectors, and <br/>not be overly repetitive or nested.</p>
					</section>

					<section>
						<h6>but what if</h6>
						<ul>
							<li>we didn't write it perfectly the first time</li>
							<li>lack of clarity</li>
							<li>hard to maintain</li>
							<li>new requirements</li>
							<li>design or UI needs to change</li>
							<li>duplication or bloat</li>
							<li>code smells</li>
						</ul>
						<aside class="notes">
							<p>So in the case we DON'T have those 4 things perfect, or in any of these other cases [read examples from slide], we refactor.</p>
						</aside>
					</section>

					<section>
						<h2>Refactoring</h2>
						<h4>changes the structure of existing code<br/> without changing its behavior</h4>
						<aside class="notes">
							<p></p>
						</aside>
					</section>

					<section>
						<h2>Refactoring</h2>
						<h4>supports the process of change</h4>
						<aside class="notes">
							<p></p>
							<p><small>Source: http://st-www.cs.illinois.edu/users/opdyke/wfo.990201.refac.html</small></p>
						</aside>
					</section>

					<section>
						<h2>Refactoring</h2>
						<h4>makes code easier to modify and <br/>maintain in the future</h4>
						<aside class="notes">
							<p></p>
							<p><small>Source: http://st-www.cs.illinois.edu/users/opdyke/wfo.990201.refac.html</small></p>
						</aside>
					</section>

					<section>
						<h3>getting everyone on the same page</p>
						<aside class="notes">
							<p>In many ways, refactoring is like exercise and eating a proper diet. Many of us know that we ought to exercise more and eat a more balanced diet. Some of us live in cultures that highly encourage this. Some of us can get by, for a while, without doing this, perhaps even without visible effects. We can always make excuses for not doing this. But, we are only fooling ourselves if we continue to ignore it. Some of us are motivated by near term benefits of exercise and eating a proper diet, such as high(er) energy levels, greater flexibility, higher self-esteem and other benefits. Nearly all of us know that these near term benefits are very real. Many - but not all - of us make at least sporadic efforts in these areas. Others, however, aren't sufficiently motivated to "do something" until they reach a crisis point.</p>
							<p><small>Source: http://st-www.cs.illinois.edu/users/opdyke/wfo.990201.refac.html</small></p>
						</aside>
					</section>

					<section>
						<h6>Why we Don't refactor</h6>
						<ul>
							<li>you/your team doesn't understand how</li>
							<li>long-term benefits aren't worth immediate effort</li>
							<li>overhead; you're paid to write new features</li>
							<li>it might break something</li>
						</ul>
					</section>

					<section>
						<p>understanding principles of why you are doing a certain way</p>
					</section>

					<section>
						<h3>Why Sass helps us refactor</h3>
					</section>

					<section>
						<h2>Systems, not Pages</h2>

						<aside class="notes">
							<p>Jina (YEAH YOU!), in her Sass presentations, says "create systems, not pages." We used to do this—about page, home page, etc etc—but now as our apps and projects have gotten significantly more complex, that's a particularly bad plan.</p>

							<p>How can you make a framework of code that is reusable and modular and separate from individual pages? Instead of "style the homepage", style the modules that are on the homepage.</p>

							<p>Your code should be reusable in as many places as possible, which makes it more efficient to write and debug.</p>

							<p>Sass helps you—or forces you—to do that. When you have the powerful tools of Sass available to you, instead of going to use the color picker to grab a shade of grey from your mockup, you know you can just write $grey. It allows you to write reusable code with very little effort.</p>

						</aside>
					</section>

					<section>
						<p>separation of concerns</p>
						<p>importing files, import order</p>
						<p>variables</p>
						<p>mixins</p>
						<p>nesting and namespacing</p>
					</section>

					<section>
						<h3>Make refactoring a regular <br/>part of your workflow</h3>
						<aside class="notes">
							<p>don't refactor everything at once; small manageable chunks</p>
						</aside>
					</section>

					<section>
						<p>keep things documented as you go</p>
					</section>

					<section>
						<p class="quote">&#8220;Sass is not a replacement for CSS, it’s more like having a CSS assistant who will help you write your code.&#8221;</p>
						<aside class="notes">
							<p>Tom Genoni wrote a blog post about switching to Sass, in which he says that the best way to learn Sass without getting the insane output is to not use the crazy functionality in Sass.</p>
							<p>"Sass is not a replacement for CSS, it’s more like having a CSS assistant who will help you write your code. So when you’re ready to really put it to work I recommend occasional sanity checks on the resulting CSS to see if this “assistant” has created too much repeated code or if the selectors are getting too complicated. Refactoring your Sass will help keep your code clean and you’ll start learning how you can make the best use of it."</p>
							<p>I personally think using variables and mixins for obvious things you will reuse (like css3, clearfix, etc) is helpful, but if you are unsure about some of the extend or nesting or functions, don't use them--keep an eye on your code. This is an authoring tool and it's supposed to make your life BETTER, not harder.</p>
							<a href="http://atomeye.com/sass-and-compass.html">http://atomeye.com/sass-and-compass.html</a>
						</aside>
					</section>

				</section>

				<section data-state="cya-starting">
					<section>
						<h2>Installation & Applications</h2>
						<p>Goal: Determine the best way to use Sass in your project.</p>
						<aside class="notes">
							<p>The tools of using Sass—how to install it, what apps and options there are.</p>
						</aside>
					</section>

					<section data-state="meridaugh gifs">
						<br><br><br><br><br><br><br><br>
						<h3>I have to use the <br> command line!?</h3>
						<aside class="notes">Yes, to install Sass you MAY have to install it via Rails in the command line. The really long and difficult command you have to write is as follows:</aside>
					</section>

					<section>
						<p><code>gem install sass</code></p>
					</section>

					<section data-state="sass-terminal">
						<code class="fragment">sass --watch /path/style.scss:/path/style.css</code>
						<aside class="notes">
							<p>When to use terminal: small personal projects that don't require many other tasks done, if you want to learn and get comfortable in Terminal, to quickly compile one file and look at output. Knowing how to use this is a handy skill in your arsenal even if you don't use it as your primary compilation option.</p>
						</aside>
					</section>

					<section data-state="codekit">
						<aside class="notes">
							<p>CodeKit helpfully compiles your stylesheets for you into regular or minified CSS, expanded or collapsed, and has LiveReload. It also now does LiveReload in multiple browsers/devices, creates source maps, and easily allows you to add plugins like Foundation, Compass, via Bower. It also does other types of processing, like Haml or Coffeescript. </p>
							<p>When to use CodeKit: if you prefer a GUI/apps, you want simple compilation AND livereload w/o using a tool like Grunt, you want to use/play with plugins without manual install.</p>
							<p>More: http://css-tricks.com/codekit-2-0/, https://incident57.com/codekit/help.html#sass</p>
						</aside>
					</section>

					<section data-state="foundation-sass">
						<aside class="notes">
							<p>If using Zurb Foundation, you can install and use the Sass version. This allows you to edit the settings and variables, rather than override their complex code. You can also pick and choose which parts of Foundation you want to import.</p>
							<p>You install it with the Foundation command line interface, which uses npm and Bower.</p>
							<p>Then you can choose one of two ways to create a project with Foundation: with Compass as the compiler (which is quite slow), and one with Grunt using the libsass compiler. Obviously the Compass one has Compass included, so you have their styles and mixins available to you automatically, but I prefer the Grunt and libsass version. I find it significantly faster. Neither of these came with livereload, though, or running a server, so you'd have to edit the own grunt file to include it. More on that and libsass later.</p>
							<p>more: http://foundation.zurb.com/docs/sass.html</p>
							<p>If you are prototyping, I <em>love</em> Foundation for this. I think it's valuable to use the Sass version, throw in your variables, colors, type, etc, and super-quickly have a sandbox where you can get a working wireframe up. I know a lot of companies that do this, whether its with Foundation, or like Happy Cog, using Compass and the Susy grid.</p>
						</aside>
					</section>

					<section data-state="libsass">
						<aside class="notes">
							<p>Libsass is a compiler for Sass that does not rely on Ruby to generate the CSS. It’s blazingly fast. You have to compile it (in C), if you are using the original version. You can install and compile it yourself with the C compiler, but there are other ways to access libsass' speed.</p>
						</aside>
					</section>

					<section>
						<h3>10x speed improvement</h3>
						<h4>2.5 seconds down to 0.2 seconds</h4>
						<aside class="notes">
							<p>This speed benchmark by Jo Liss http://www.solitr.com/blog/2014/01/css-preprocessor-benchmark/ tested Libsass as providing a massive (>10x) speed improvement over the original Sass compiled in Ruby, dropping processing time from 2.5 seconds to 0.2 seconds.</p>
							<p>She says, "The speed of your CSS preprocessor is important for developer/designer ergonomics. The preprocessing time measured by this benchmark will typically incur as a delay every time you edit the stylesheet sources and hit reload in the browser. Delays below 0.2 to 0.5 seconds tend to be perceived by the human brain as near-instantaneous. The higher the delay, the higher the mental overhead."</p>
							<p>So—we want to be able to use libsass, that's awesome. But I don't feel like trying to deal with a C compiler. Luckily...</p>
						</aside>
					</section>


					<section data-state="node-sass">
						<aside class="notes">
							<p>Node-sass is a library that provides binding for Node.js to libsass.</p>
							<p>This is great if you are using Node, or other JS apps.. or Grunt. Or the Foundation libsass option. They all use the nodesass bind to libsass to compile.</p>

							<p>More: http://benfrain.com/lightning-fast-sass-compiling-with-libsass-node-sass-and-grunt-sass/</p>

						</aside>
					</section>

					<section data-state="sass-maps">
						<aside class="notes">
							<p>And no.. libsass does not yet support Sass 3.3, so it does not support maps. This is probably the biggest complaint we hear about libsass. So if you use the Foundation libsass version, you can't use maps, or plugins like Susy that require Sass 3.3</p>
							<p>On screen is a color-guide that Una Kravets made, and it's using the maps functionality to do so. When I try to copy this into my Foundation-with-libsass project, I get the following error:</p>
							<p>More: http://unakravets.tumblr.com/post/67057158293/use-sass-3-3-maps-to-make-on-the-fly-color-guides, http://sassmeister.com/gist/7479693, https://github.com/ericam/susy/issues/285, http://benfrain.com/libsass-lightning-fast-sass-compiler-ready-prime-time/</p>
						</aside>
					</section>

					<section data-state="full-code">
						<code style="color:white;">
$ grunt<br/>
Running "watch" task<br/>
Waiting...OK<br/>
>> File "scss/app.scss" changed.<br/><br/>

<span style="color:yellow;">Warning: /Users/elyse/Documents/test-libsass/scss/app.scss:61: error:
 error reading values after brick-red</span><br/><br/>

<span style="color:red;">Aborted due to warnings.</span>
						</code>

					</section>

					<section data-state="white">
						<img src="/images/grunt-logo.png" alt="" style="margin-right: 250px;">
						<img src="/images/gulp-logo.png" alt="">
						<aside class="notes">
							<p>Sooo... Grunt, Gulp, Broccoli, whatever it is nowadays! When I first started getting in to these, I'd ask what they did and people go, "Oh, they're task runners!" Which I think has become one of those non-answers. It's TRUE but I don't think particularly explanatory if you have never used them or don't know what a task being run might even mean.</p>

							<p>Tasks are things like compiling sass, concat/minify js and css, run a local server, live reload, optimize images. Instead of using an app like CodeKit to do that, if we are writing a JS or Rails app, we can write JS to define these tasks, and run them in the Terminal.</p>

							<p>If you are using Grunt or Gulp, and don't need Sass 3.3 features like maps, you can use the grunt-sass plugin—not to be confused with grunt-contrib-sass, the ruby version grunt plugin. grunt-sass compiles with libsass and should be very quick in comparison.</p>

							<p><small>Source: http://24ways.org/2013/grunt-is-not-weird-and-hard/</small></p>
						</aside>
					</section>


					<section data-state="full-code">
						<pre><code class="JSON">
  grunt.initConfig({
	watch: {
	  css: {
		files: ['Gruntfile.js', 'app/**/*.js', './app/scss/**/*.scss']
	  },
	  livereload: {
		options: { livereload: true }
	  }
	},

	connect: {
	  server: {
	options: {
	  port: 8000,
	  base: './app',
	  livereload: true
	}
	 }
	},

	open: {
	  dev : {
	path: 'http://localhost:8000'
	  }
	}
  });

  // Server Task
   grunt.registerTask('server', [
	  'connect',
	  'open',
	  'watch'
  ]);
						</code></pre>
						<aside class="notes">
							<p>In plain English: you write some JavaScript/JSON and define some tasks that need to be done. Here we make a task to compile sass and watch for changes, connect to a server and open it. Then, in Terminal, you can run those tasks with a command like "grunt server", and it would connect to a local server, open it in the browser for you, compile files and watch for changes and livereload...</p>
						</aside>

					</section>

					<section data-state="full-code">
						<pre><code>
  // npm install
  grunt-contrib-sass       // Compile Sass to CSS with Ruby compiler
  grunt-sass               // Compile Sass to CSS using node-sass/libsass
  grunt-contrib-connect    // Start a web server
  grunt-open               // Open server in your browser automatically
  grunt-contrib-watch      // Watch for file changes
  connect-livereload       // Auto-reload browser with files are changed
  grunt-contrib-imagemin   // Minify PNG and JPG images
  grunt-contrib-htmlmin    // Minify HTML
  grunt-contrib-cssmin     // Minify compiled CSS files
  grunt-autoprefixer       // Adds vendor prefixes automatically
						</code></pre>

						<aside class="notes">
							<p>Useful grunt plugins</p>
						</aside>
					</section>

					<section>
						<p class="quote"><a href="http://24ways.org/2013/grunt-is-not-weird-and-hard/">Grunt for People Who Think Things <br/>Like Grunt are Weird and Hard</a></p>
						<h6>by Chris Coyier</h6>
						<aside class="notes">
							<p><small>Source: http://24ways.org/2013/grunt-is-not-weird-and-hard/</small></p>
						</aside>
					</section>

					<section>
						<h2>.scss or .sass?</h2>
						<p>Goal: Choose a syntax for your project.</p>
					</section>

					<section>
						<h3>Steps to switch to .scss</h3>
						<ol>
							<li>change all your <code>.css</code> files to <code>.scss</code></li>
							<li>compile your code</li>
							<li>Open your site in a browser</li>
						</ol>
					</section>

					<section data-state="sciencedino gifs">
					</section>

					<section>
						<h3>.sass vs .scss</h3>
						<p>Sass* (the language) has two syntaxes</p>
						<p class="footnote">* it's not an acronym!</p>
					</section>

					<section>
						<h3>.scss</h3>
						<p>SCSS* or "Sassy CSS" looks just like CSS.<br/>Every <code>.css</code> file is a valid <code>.scss</code> file.</p>
						<pre>
						<code class="sass">
  .widget {
    color: #fff; /* CSS works here */
    background: $backgroundColor; /* but so do Sass variables */
    margin: 20px;
    padding: 20px;
  }
						</code>
						</pre>
						<h6>* it's an acronym!</h6>
						<aside class="notes">
							<p>.scss is a much easier place to begin, though, since it's a lot more forgiving and accepts all regular CSS.</p>
							<p>If you are switching from .css, or have a lot of devs/people on your project that are not as familiar with CSS, this is probably a good option. It can also be more convenient if you are pulling in lots of vendor or framework code.</p>
						</aside>
					</section>

					<section>
						<h3>.sass</h3>
						<p><code>.sass</code> syntax uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties.</p>
						<pre>
						<code class="sass">
  .widget /* look ma, no brackets! */
    color: #fff /* or semi-colons! */
    background: $backgroundColor
    margin: 20px
    padding: 20px

  // you can use shorthand includes
  =large-text // instead of @mixin large-text
    font-size: 20px
    color: #ff0000

  h1
    +large-text // instead of @include large-text
						</code>
						</pre>

						<aside class="notes">
							<p>I personally like the .sass syntax; I find it forces me to be more cautious about nesting, and I love not typing brackets or semicolons.</p>
							<p>It's a good choice for those familiar with things like HAML, or who like significant whitespace, or like me, are lazy. It's also less to type if you use the oldschool syntax. Instead of writing @mixin, you can use the character =; instead of writing @include, you can use the character +</p>
						</aside>
					</section>

					<section>
						<h3>Converting .(s)css to .sass</h3>
						<pre>
						<code class="sass">
  /* SCSS using indentation as relationship */
  .nav {
    styles: go here;
  }
    .nav-item {generic: styles;} // indented under .nav but NOT nested

  // .sass syntax uses indentation as nesting
  .nav
    styles: go here
    .nav-item // now will output as .nav .nav-item
      generic: styles // now are possibly not generic anymore
						</code>
						</pre>
						<aside class="notes">
							<p>It can be difficult to switch from .scss to .sass if you use indentation in .scss to denote relationships. If you do that in .sass, it will be nested. You have to take the time when switching to make sure your code isn't all crazy nested (and therefore potentially broken).</p>
							<p>in the above example, let's imagine that the .nav-item styles apply to .nav and also to .footer-nav; in the .sass syntax case that would no longer be true, and your styles would be broken.</p>
						</aside>
					</section>

				</section>


				<section data-state="cya-import">
					<section>
						<h2>Importing</h2>
						<p>Goal: Choose how to import and organize your code.</p>
					</section>

					<section>
						<h5>create an application.scss manifest file</h5>
						<aside class="notes">
							<p>The first thing you can do is to import everything thru your compiled Sass file; create an application.scss/sass file and link to it from your app. If you're linking to multiple CSS files, import them from your manifest instead.</p>
						</aside>
					</section>

					<section>
						<pre><code>
  @import [framework or vendor css]
  @import styles.scss
						</code></pre>
						<aside class="notes">
							<p>Maybe this is all you have right now—but you've created a manifest that you can add files to as you go.</p>
						</aside>
					</section>

					<section>
						<h5>break up existing files and import them</h5>
					</section>

					<section>
						<p>Break out related sections of code, e.g. errors/messages, buttons, icons, nav, etc.</p>
						<p class="fragment">Make a new file for each with a comment explaining what is in the file.</p>
						<p class="fragment">Keep files small and readable.</p>

						<aside class="notes">
							<p>Here we are still aiming to have no (or at least very little) visual change on the site. By doing this we just want to group our files, NOT start changing our CSS, classnames, etc.</p>
							<p>This isn't about creating modules, which may edit your output or HTML, or require HTML cleanup. This is just about taking your existing CSS and dumping it into smaller, grouped files. Keep it as simple as you can. A big part of refactoring is choosing small battles; if you try to do it all at once you will always give up.</p>
						</aside>
					</section>

					<section>
						<h5>import without altering existing CSS output order</h5>
						<aside class="notes">
							<p>This is something you just have to do manually and slowly. Presumably, in your CSS, you'll have sections. If you have a section, you can copy it wholesale into a new file and import it. If you import them in the same order as they were in the CSS file, you shouldn't have any errors. Obviously this is not foolproof!</p>
							<p>As you create new modules later, you can write your code in ways that make it less fragile to output order (namespacing, etc).</p>
						</aside>
					</section>

					<section>
						<h5>reorganize/regroup my files/folders</h5>
						<aside class="notes">
							<p>If you already have imported files via a manifest, you may just need to reorganize or regroup them. Remember that you can group into as many folders as you need to make sense of your files. We'll talk more about folder org, architecture, and creating modules later.</p>
						</aside>
					</section>

				</section>

				<section data-state="cya-variables">
					<section>
						<h2>Creating Variables</h2>
						<p>Goal: Create simple, new variables that don't alter output.</p>
					</section>

					<section>
						<h3>Variables</h3>
						<p><code>cmd(+opt)+F</code> in Sublime Text is your new BFF.</p>

						<aside class="notes">
							<p>Color variables will make you more consistent both visually and in your CSS, and you'll never have to search for a hex color code in your CSS ever again.</p>
						</aside>
					</section>

					<section>
						<ol>
							<li>Make a new file: <code>colors.scss</code></li>
							<li class="fragment">Make a new variable: <code>$white: #ffffff;</code></li>
							<li class="fragment">Search for all the <code>#ffffff</code>, <code>#fff</code>, <code>#FFF</code>, <code>white</code>, maybe even <code>#f9f9f9</code>.</li>
							<li class="fragment">Replace them with <code>$white</code></li>
							<li class="fragment">Now do the rest!</li>
						</ol>
						<aside class="notes">
							<p>Now is a really good time to take a little inventory of the UI of your app. What _should_ be white but is actually a super light grey? Do you have two VERY similar colors of blue? Can you consolidate some of your colors as you go to make things more efficient?</p>
						</aside>
					</section>

					<section>
						<p>Import <code>colors.scss</code> into your manifest FIRST.</p>
						<aside class="notes">
							<p>Now you can import this file into your manifest; of course it has to go first. Now is a good time to do a visual runthrough and make sure you aren't seeing anything that doesn't work. Maybe your #f9f9f9 really did need to be that, and not white. Just check. This is harder on a larger project, but whether you're checking visually or in your codebase (e.g. did you make an element w/ the bg and color both $white) you should take the time. If you already have something like visual diff testing set up, that'd be another great way to test.</p>
						</aside>
					</section>

					<section>
						<h3>Use color operations to make variations.</h3>
						<aside class="notes">
							<p>Use Sass' built in color operations to make a light grey that is just a lighter version of our dark grey, rather than defining a new hex value. I'm also using transparentize to make an rgba color for transparent text, rather than defining another rgba color.</p>

							<p>Sass has a ton of these: lighten, darken, saturate, desaturate, invert, complement, adjust hue, alpha (returns alpha value), opacify/transparentize (not kidding, real names- makes more or less opaque), even "change-color" to change any property of a color: red, green, blue values, hue, saturation, lightness, and alpha.</p>

							<a href="http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html">http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html</a>
						</aside>
					</section>

					<section>
						<h3>Typography Variables</h3>
							<pre>
						<code class="sass">
  // TYPEFACE VARIABLES
  $fontHeadline: "Proxima Nova Bold", "Calibri", Arial, sans-serif;
  $fontBody: "Calluna", "Cambria", Georgia, sans-serif;
  $fontSecondary: "Proxima Nova Light", "Calibri", Arial, sans-serif;
						</code>
						</pre>
						<aside class="notes">
							<p>Here I've defined a headline font, a body font, and a "secondary" font, in case we ever wanted to use that. Like colors, this allows us to change everything in only one place.</p>
						</aside>
					</section>

					<section>
					<h5>typography variables</h5>
					<pre>
						<code class="sass">
  body {
	background: $white;
	font-family: $fontBody
	color: $greydark;
  }

  h1, h2, h3, h4, h5 {
	line-height: 1.2em;
	font-family: $fontHeadline;
	color: $highlight_color_bright;
  }
						</code>
					</pre>
						<aside class="notes">
							<p>So here I am pointing our body font to $fontBody, and our headlines to $fontHeadline. Note that it's possible to point the $fontBody variable or vice versa in your variable declarations, if you only wanted one font. I'd still define 2 variables, and use them appropriately: for an h2, I'd use $fontHeadline; if it was in the body or a paragraph declaration, I'd use $fontBody. Even though $fontBody points to $fontHeadline, let's imagine change it later. If you used $fontHeadline in the body declaration, and changed the $fontBody variable, your body font wouldn't change.</p>
						</aside>
					</section>

					<section data-state="fontsizes">
						<h3>it works for font-size too</h3>
						<aside class="notes">
							<p>Harry Roberts of CSS Wizardry wrote an article called "Pragmatic, practical font sizing in CSS" and in it he came up with this greek lettering method of naming font sizes. Instead of ONLY defining your font sizes on h1, h2, h3, etc, we also define it on classes alpha, beta, etc. "So now .alpha can carry the style information of a h1 wherever you wish; it doesn’t depend on location or a type of element."</p>
							<p>I took that one step further with Sass, and used the new placeholder extend functionality. Now I don't have to have classnames in my HTML, but I can extend them in my Sass, like this:</p>
						</aside>
					</section>

					<section>
						<h5>font-size extends</h5>
					<pre>
						<code class="sass">
  .notification {

	  &:hover { background: lighten($tertiary_color,25%); }

	  // read state of a notification
	  &.read { background: transparentize($tertiary_color,75%); }

	  .icon_arrow_right {
		  @extend %milli;
		  color: $greylight;
	  }

	  .icon_notification {
		  @extend %delta;
		  color: $primary_color_bright;
		  padding: 5px 10px 0 0;
		  float: left;
	  }

	  .notification_title {
		  padding: .75em .5em;
		  border-bottom: 1px solid $greypale;
		  @extend %zeta;
	  }
  }
						</code>
					</pre>
						<aside class="notes">
							<p>Just @extend %delta, and you'll get 18px, without having to put the classname in your HTML. Additionally, from the content in the typography.sass file, h4 is output, but %delta itself isn't. You could take that one step further and eliminate the h1-6 selectors and ONLY use the placeholders, if you wanted. This works really well for me at work, because in our complex app, we prefer to use unique classnames over HTML selectors, to eliminate cascade issues. For clarity, I also like to not have non-informational classnames in my HTML, like, .delta. If you are working on your own blog or something smaller, it probably isn't as necessary to either eliminate this much CSS output, or avoid the classnames, but whether or not you use placeholder or classes, this is still a very valuable organization technique.</p>
							<p>You should be able to do this without really changing much of your output CSS. If you go through the places in your codebase that you have font-size declarations, the same as we did for color variables, and replace with @extend .delta (whether that's a class or placeholder), you'll get the exact same output. If you are adding line-height to your typography.scss file you might have to be a bit more careful. Now you also have consistency going forward. </p>
						</aside>
					</section>

					<section>
						<aside class="notes">
							<p>[are we missing any other vars we should talk about - basics? for example: grids, margin/padding...? I think button abstraction, grids w loops, etc, should be in the next section]</p>
						</aside>
					</section>

				</section>

				<section data-state="cya-abstracting-vars">
					<section>
						<h2>Variable Abstraction</h2>
						<p>Goal: Clarify variable names, create themes, named media queries.</p>
					</section>

					<section data-state="white">
						<img src="https://cdn.tutsplus.com/webdesign/uploads/2013/07/var-variable-names.png" alt="">
						<aside class="notes">
							<p>Say you need a variable for text color in your project. You could call it $text-color, or should you call it $color-text? How do you decide? Choosing one at random can contribute to a lack of structure as the number of variables in your project increases. As experience shows, we often forget exactly how we named variables for particular projects.</p>
							<p>http://webdesign.tutsplus.com/articles/quick-tip-name-your-sass-variables-modularly--webdesign-13364</p>
						</aside>

					</section>

					<section>
						<h3>Shared Name First</h3>
						<pre><code>
  // by shades...                       // better: by shared name
  $blue;                                $blue;
  $medium-blue;                         $blue-medium;
  $dark-blue;                           $blue-dark;
  $darkest-blue;                        $blue-darkest;
  $light-blue;                          $blue-light;
  $lightest-blue;                       $blue-pale;
						</code></pre>
						<aside class="notes">
							<p>A better way to name these variables would be to start with the generic word they all share in common: blue. Then we can get more specific from left to right:</p>
							<p>This not only helps in recollection, but will allow a text editor (such as Sublime Text, Coda etc.) to easily suggest colors. This way you don't have to memorize exactly how you named your variables. Rather, you can start generically and get more specific as the text editor auto-suggests variable names. All you have to remember is you want a color of blue. So you begin typing $blue and you can get a list of all the different blues you've created!</p>
						</aside>
					</section>

					<section>
						<h4>Abstracted Variable Names</h4>
						<pre><code>

  $header-primary
  $header-secondary
  $header-tertiary

  $background-color-default
  $background-color-highlight
  $background-color-lowlight
  $background-color-dark

  $button-bg
  $button-border
  $button-shadow
  $button-color
  $button-bg-hover
  $button-border-hover
  $button-shadow-hover
  $button-color-hover
						</code></pre>
					</section>

					<section>
						<h3>Creating Simple Themes</h3>
					</section>

					<section data-state="full-code">
						<pre><code class="scss">
// COLORS.SCSS ------------------------------------------ //

// Blues ------------------------------------------------ //
$navy: rgb(1, 46, 81); // MKS Navy
$blue-dark: rgb(23, 75, 133);
$blue-bright: rgb(35, 128, 226); // MKS Primary Blue
$blue-light: rgb(99, 159, 222);
$blue-pale: rgb(206, 226, 247);

// Secondary colors ------------------------------------- //
// use sparingly, for contrast and highlight only
$orange: rgb(255, 152, 0);
$orange-light: lighten($orange, 50%);
$orange-dark: rgb(194, 105, 1);

$green: rgb(130, 179, 0);
$green-light: lighten($green, 50%);
$green-dark: rgb(18, 120, 0);
						</code></pre>
						<aside class="notes">
							<p>Using a consistent naming convention, we can create a colors (or vars) .scss file and put in our colors, typography, etc.</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code class="scss">
// ------------------------------------------------------ //
// DEFAULT THEME ---------------------------------------- //
// ------------------------------------------------------ //


// Theme colors ----------------------------------------- //

$primary-color: $navy;
$secondary-color: $blue-bright;
$tertiary-color: $grey-dark;
$highlight-color: $green;


// Text, Link, and Header colors ------------------------ //

$text-color: $black;
$text-color-sub: $grey;
$text-color-reverse: $off-white;

$header-color-primary: $navy;
$header-color-secondary: $blue-bright;
$header-color-tertiary: $blue-dark;

$link-color: $secondary-color;
$link-color-hover: $highlight-color;


// Background colors ------------------------------------ //

$background-color-default: $white;
$background-color-light: $off-white;
$background-color-dark: $navy;
$background-color-standout: $blue-bright;


// Button colors ---------------------------------------- //

$button-bg: $green;
$button-color: $white;
$button-bg-hover: $green-dark;
$button-color-hover: $white;
						</code></pre>
						<aside class="notes">
							<p>Then we can create theme files; a default, a dark, a light, etc, using the color vars against more abstracted var names like primary, secondary, button-bg, etc.</p>
						</aside>
					</section>

					<section>
						<h3>Creating Configuration Files</h3>
						<aside class="notes">
							<p>A simple theme is a nice way to separate out colors, if you need it, but you can take it one step further and break things out into a config.</p>
							<p>This config is then called into the app manifest; you can call different configs, or change it based on what's required for the project/theme.</p>
							<p>This also helps with keeping functions/helpers out of style code</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code class="scss">
// ------------------------------------------------------ //
// Configuration File Import ---------------------------- //
// ------------------------------------------------------ //

// Import the configuration file that sets default variables
@import "config/config";

// Import helpers, vars, and mixins
@import "config/helpers";
@import "config/colors";

// Choose theme
@import "config/theme-mks-default";
// @import "config/theme-mks-dark";
// @import "config/theme-mks-light";

// Import webfonts, typography
@import "config/webfonts";
@import "config/typography";
						</code></pre>
						<aside class="notes">
							<p>Then we have the ability to change out the theme we are using pretty much on the fly, by picking which file we import.</p>
						</aside>
					</section>

					<section>
						<pre><code class="scss">
// ------------------------------------------------------ //
// CONFIGURATION & SETTINGS ----------------------------- //
// ------------------------------------------------------ //
// In the config file you can edit colors, typography,
// and general default variables. Note that all variables
// have the !default flag this means that they can be
// overridden by variables later in the Sass workflow.
// This will allow us to create themes easily, if we
// choose.


// Font Sizing ------------------------------------------ //
// ------------------------------------------------------ //

// Base font size  -------------------------------------- //
// 16px is the browser default.

$base-font-size: 1em !default

// Font Sizes  ------------------------------------------ //

$giga: 4.5em !default
$alpha: 3.662em !default
$beta: 2.930em !default
$gamma: 1.875em !default
$delta: 1.5em !default
$epsilon: 1.2em !default
$zeta: .875em !default
$iota: .75rem !default

// Line Heights ----------------------------------------- //

$line-base: 1.5 !default
$line-large: 1.75 !default
$line-small: 1.25 !default

// Typography ------------------------------------------- //
// ------------------------------------------------------ //


// Body text -------------------------------------------- //

$body-fallback: 'Cambria', 'Lucida Bright', 'Georgia', serif

$body-font: 'adelle', $body-fallback !default
$body-bold: 'adelle-bold', $body-font !default
$body-italic: 'adelle-italic', $body-font !default


// Alternate Body text ---------------------------------- //

$body-font-alt-fallback: 'Geneva', 'Franklin Gothic', 'Calibri', 'Arial Narrow', 'Helvetica', sans-serif

$body-font-alt: 'pluto-sans-condensed-light', $body-font-alt-fallback !default
$body-font-alt-bold: 'pluto-sans-condensed-regular', $body-font-alt !default


// Headers ---------------------------------------------- //

$header-fallback: 'Geneva', 'Franklin Gothic', 'Calibri', 'Arial Narrow', 'Helvetica', sans-serif

$header-primary: 'pluto-sans-condensed-thin', $header-fallback !default
$header-secondary: $body-font !default
$header-secondary-bold: $body-bold !default
$header-tertiary: $body-font-alt-bold !default


// Navigation ------------------------------------------- //

$nav-font: 'pluto-sans-condensed-medium', $header-fallback !default


// Code Blocks  ----------------------------------------- //

$code-fallback: 'Inconsolata', 'Monaco', 'Consolas', monospace

$code-font: 'fira-mono', $code-fallback !default
$code-font-bold: 'fira-mono-medium', $code-font !default


// Buttons  --------------------------------------------- //

$button-font: 'pluto-sans-regular', $header-fallback !default


// Font Awesome  ---------------------------------------- //

$icon-font: 'font-awesome' !default


// Borders ---------------------------------------------- //
// ------------------------------------------------------ //

$border-width-default: 6px
$border-width-small: 2px
$border-width-link: 1px
$border-width-large: 12px

$border-radius-default: 4px

						</code></pre>
					</section>

					<section>
						<pre><code class="scss">
// -------------------------------------------------- //
// TYPOGRAPHY --------------------------------------- //
// -------------------------------------------------- //
// variables are set in _config.sass and themes



// Body text -------------------------------------------- //
body
    font-family: $body-font
    font-size: $base-font-size
    line-height: $line-base



// Headers ---------------------------------------------- //


h1, h2, h3, h4, h5, h6
    line-height: $line-small // keep line-height smaller if they stack
    margin: 0
    text-rendering: geometricPrecision

// h1 - Pluto SC Thin 60px+
h1
    font-family: $header-primary
    @include breakpoint(tiny)
        font-size: $beta
    @include breakpoint(medium)
        font-size: $alpha


// h2 - Adelle 46px
h2
    font-family: $header-secondary
    font-size: $beta


// h3 - Pluto SC Regular 30px
h3
    font-family: $header-tertiary
    font-size: $gamma
						</code></pre>
					</section>

					<section><code>
							<pre class="scss">
// ------------------------------------------------------ //
// APPLICATION IMPORT ----------------------------------- //
// ------------------------------------------------------ //

@import "config"
@import "layout"
@import "modules"
							</pre>
						</code></section>

					<section>
						<h2>Named Media Queries</h2>
					</section>

					<section data-state="full-code">
						<aside class="notes"><p>
							Media queries in Sass behave the same as in CSS, except they can be nested inside a CSS rule.
						</p></aside>

						<pre>
						<code class="scss">
  // SCSS
  .sidebar {
	 width: 300px;
	 @media screen and (min-width: 1000px) {
	  width: 500px;
	 }
  }


  /* OUTPUT - Same as CSS */
  .sidebar {
	 width: 300px;
  }

  @media screen and (min-width: 1000px) {
	 .sidebar {
	  width: 500px;
	 }
  }
						</code>
						</pre>

						<aside class="notes">"@media directives in Sass behave just like they do in plain CSS, with one extra capability: they can be nested in CSS rules. If a @media directive appears within a CSS rule, it will be bubbled up to the top level of the stylesheet, putting all the selectors on the way inside the rule. This makes it easy to add media-specific styles without having to repeat selectors or break the flow of the stylesheet."</aside>
					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  // Define your breakpoint sizes; these are based on min-width MQ's
  // e.g. tiny is 0-499px
  $tiny: 0;
  $small: 500px;
  $medium: 1000px;
  $large: 1300px;
						</code>
						</pre>
					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  // Breakpoint mixin
  @mixin breakpoint($media) {
	// if the media is 'tiny'
	@if $media == tiny {
	  // define mediaquery with variable
	  @media only screen and (min-width: $tiny) {
		// print content CSS
		@content
	  }
	}

	@else if $media == small {
	  // small and medium are 1px smaller than their previous variable
	  @media only screen and (min-width: $small - 1) {
		@content
	  }
	}

	@else if $media == medium {
	  @media only screen and (min-width: $medium - 1) {
		@content
	  }
	}

	@else if $media == large {
	  @media only screen and (min-width: $large) {
		@content
	  }
	}
  }


						</code>
						</pre>
						<aside class="notes">
							<p>This is another good example of a Sass if statement; here we are defining a mixin with an argument of $point, and then saying, if my $point value that gets passed in my include is large, then print out this mediaquery, and the @content of it inside it.</p>
						</aside>

					</section>

					<section>
						<h5>So you can do this magic:</h5>
						<pre>
						<code class="scss">
  .page-wrap {
	@include breakpoint(tiny) { width: 95%; } // at 0 to 499px
	@include breakpoint(small) { width: 80%; } // at 500px to 999px
	@include breakpoint(medium) { width: 70%; } // at 1000px to 1299px
	@include breakpoint(large) { width: 60%; } // 1300px and up
  }
						</code>
						</pre>

						<aside class="notes">
							<p>This is a much nicer way to author mediaqueries; it makes it easy to see what styles are related to what MQ size, you never have to write the #s again, or go searching through 2 different files to debug styles.</p>
							<p>More: <a href="http://css-tricks.com/media-queries-sass-3-2-and-codekit/">Chris Coyier's CSS-tricks Named Media Queries article.</a></small></p>
						</aside>

					</section>

				</section>

				<section data-state="cya-organization">
					<section>
						<h2>Organize files and folders</h2>
						<p>Goal: Keep style, vendor, and helper code separate; make files easy to find and not cluttered.</p>
					</section>

					<section>
						<p>config: settings, variables</p>
						<p>themes, if you have any</p>
						<p>helpers: mixins, JS state classes, CSS3</p>
						<p>frameworks: foundation, bootstrap, grids</p>
						<p>components: icons, buttons, page components like header/footer</p>
						<p>modules/base: your semantic HTML - page content, not elements like buttons</p>
						<p>IE or responsive if you keep it separate</p>
						<p>vendor: third party libraries, JS</p>
					</section>

					<section>

						<pre><code>
|- sass/
|--- application.sass    // manifest, imports config, components, modules, frameworks
|--- config.sass         // imports actual config file, helpers, colors, typography, themes
|--- config/
|------ _config.sass
|------ _helpers.sass    // includes mixins, testing functions, css3, js is- states
|------ _colors.sass
|------ _typography.sass // webfonts and type declarations
|--- components.sass     // imports icons, buttons, UI elements, page components
|--- components/
|------ page.sass        // general page/body
|------ header.sass
|------ footer.sass
|------ buttons.sass
|------ icons.sass
|------ nav.sass
|------ forms.sass
|--- modules.sass        // imports page content and semantic HTML
|--- modules/
|------ [your page content files]
|--- vendor.sass         // imports CSS from third party or JS libs

						</code></pre>
					</section>

					<section data-state="import2">
						<aside class="notes">
							<p>Here's how I do it on my blog.</p>
							<p>In this case, I did style somewhat by "pages"—but on a small site like this, that's totally fine.</p>
						</aside>
					</section>

					<section data-state="dale-sande">
						<br/><br/><br/><br/><br/><br/>
						<a href="http://moourl.com/junk" class="ref-link"><span class="ref-arrow">&#10172; moourl.com/junk</a><br/>
						<a href="http://moourl.com/junkvid" class="ref-link"><span class="ref-arrow">&#10172; moourl.com/junkvid</a>
						<aside class="notes">
							<p>Dale Sande gave a great talk called Clean out your Sass junk drawer, and he goes way in depth on some ways to do this.</p>
							<p>"While part of a team developing an enterprise CMS, our process was to decompose a site's UI to it's lowest common elements. From those elements we could then build modules and then finally assemble the view templates. Each step building on the previous. Although my stylesheet management techniques weren't perfect, my concept of UI abstraction was solid.

							Working with a new team, sans a CMS, I went into the project with the same conceptual understanding, but the outcome was drastically different. The code became increasingly harder to reuse and making simple edits resulted in the reengineering of HTML as well as CSS. Post launch, I sat down and analyzed the code I wrote. I came to the realization that we were engineering our UI (CSS and HTML) from entirely the wrong perspective. We were approaching our development from the full page perspective. Engineering all our visual elements from the outside-in and scoped to a specific view.

							I started thinking back to the processes I pioneered with the CMS. Patterns established in the framework dictated we start from the elemental perspective; type, colors, forms, basic UI chrome (borders, shadows, icons, etc) all coded first. Once those element styles were completed, it was a matter of applying the skin to the CMS modules. The modules then in-turn were used to assemble the view. It worked quickly and seamlessly. Building the UIs from the inside-out was clearly the solution."</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>
|- sass/
|--- buttons/
|--- color/
|--- forms/
|--- layouts/
|--- modules/
|----- registration/
|------- _extends.scss
|------- _functions.scss
|------- _mixin.scss
|------- _module_registration.scss
|--- typography/
|--- ui_patterns/
|--- _buttons.scss
|--- _config.scss
|--- _forms.scss
|--- _typography.scss
|--- style.scss
						</code></pre>
						<aside class="notes">
							<p>His mantra is "code the element, create the module and assemble the layout."</p>
							<p>Elemental partials is where we get to work. Here we write Sass rules that will create your UI foundational layer. _buttons.scss, _forms.scss, _global_design.scss, _reset.scss and _typography.scss all contain Sass rules that will process into CSS. While they will import other partials, mixins and silent placeholder rules, it is important to remember that these files are engineered only to output CSS.

							Taking buttons as an example; between gradients, :hover and :active states, one could go a little mad over the complexities in styling. It is important to keep your Sass logic out of these files and focus purely on the rules that will produce CSS for your selector.

							Keeping functional Sass separate from presentational Sass is important in order to maintain readability, search-ability and scaleability of your code. Patterns like placing mixins in the same file as presentational Sass leads to overly complex files to scan and opportunities for accidental pollution of your processed CSS.</p>
						</aside>
					</section>

					<section data-state="sassystarter">
						<h3 style="color:#666; text-transform: none;">Mina Markham's Sassy Starter</h3>
						<a href="http://moourl.com/sassystarter" class="ref-link"><span class="ref-arrow">&#10172; moourl.com/sassystarter</a><br/>
						<aside class="notes">
							<p>Mina Markham wrote a GREAT starter toolkit based on Scalable and Modular Architecture for CSS SMACSS for Sass (SCSS) projects. Styles are broken down into the following groups: Base, Layout, Modules, States, Themes</p>
							<p>If you are starting a project and want some guidance on organization, I think this is an awesome, super simple place to start. Unlike a framework that provides all this code for you, Mina's starter is just placeholder docs.. the files are created, but empty, ready for YOUR code!</p>
							<p>Link: https://github.com/minamarkham/sassy-starter</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code class="scss">

  + scss/
  |
  | + base/                 # reset, typography, site-wide
  |   |-- _index.scss       # imports for all base styles
  |   |-- _base.scss        # base styles
  |   |-- _normalize.scss   # normalize v3.0.1
  |
  | + layout/               # major components, e.g., header, footer etc.
  |   |-- _index.scss       # imports for all layout styles
  |
  | + modules/              # minor components, e.g., buttons, widgets etc.
  |   |-- _index.scss       # imports for all modules
  |
  | + states/               # js-based classes, alternative states
  |   |-- _index.scss       # imports for all state styles
  |   |-- _states.scss      # state rules
  |   |-- _print.scss       # print styles
  |   |-- _touch.scss       # touch styles
  |
  | + themes/               # (optional) separate theme files
  |   |-- beccapurple.scss  # rename to appropriate theme name
  |
  | + utilities/            # non-CSS outputs (i.e. mixins, vars)
  |   |-- _index.scss       # imports for all mixins + global project vars
  |   |-- _fonts.scss       # font mixins
  |   |-- _functions.scss   # ems to rems conversion, etc.
  |   |-- _global.scss      # global variables
  |   |-- _helpers.scss     # placeholder helper classes
  |   |-- _mixins.scss      # media queries, CSS3, etc.
  |   |-- _lib.scss         # imports for third party styles
  |   |-- + lib/            # third party styles
  |       | _pesticide.scss # CSS pesticide
  |       | ...
  |
  |   + ie.scss             # IE specific Sass file
  |   + styles.scss         # primary Sass file
  |   + _shame.scss         # because hacks happen
  |
  + .htaccess               # Apache server configs
  + config.rb               # Compass configuration file
  + crossdomain.xml         # cross-domain requests
  + docs/                   # SassDoc generated documentation
  + deploy.rb               # Capistrano configuration file
  + Gruntfile.js            # Grunt configuration & tasks
  + package.json            # Grunt metadata & dependencies
						</code></pre>
					</section>

				</section>



				<section data-state="cya-modules">
					<section>
						<h2>Creating Modules</h2>
						<p>Goal: determine what modules your project has & how to group them</p>
					</section>

					<section>
						<p>systems, not pages</p>
					</section>

					<section>
						<p>how to determine WHAT modules you have; going thru old html and css and determining what is the same and what is different</p>
					</section>

					<section>
						<p>print your website out on paper!</p>
						<aside class="notes">
							<p>No but srsly. At Bazaarvoice we had 3 separate codebases, one for Reviews, one for AA, one for Stories. We wanted to consolidate the CSS, but it was too big of an undertaking to refactor all the HTML and UI components.</p>
							<p>So what we did is we printed out every page/area of our software. Then we took them in groups and with colored pencils, boxed out what sections were the same.</p>
							<p>All primary buttons got one color, secondary another. Common form elements got one; headers another. After that we boxed out larger page modules, like "comment" and "comment form" and larger than that, "comment area".</p>
							<p>This helped us determine what our modules were. Even though we couldn't change our HTML, when we were writing our Sass (ok, LESS) templates, we could group all the relevant CSS classnames together in one declaration, rather than having multiple redundant files.</p>
						</aside>
					</section>

					<section>
						<p>which need a parent to have a style change under (namespacing); WHERE they are and which should be the same</p>
					</section>

					<section>
						<h3>&amp; parent selector</h3>
						<aside class="notes">
							<p>Some other tips for eliminating extra output—other than not matching your HTML in your Sass—are things like the parent selector, placeholder extend, and using them to namespace modules. Not only can this help eliminate extra output, but it can also make AUTHORING a lot easier.</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code class="scss">
  // SCSS
  .button {
	background: $red;
	&:hover { background: $blue; }
	&.is-active { background: $green; }
  }

  /* OUTPUT */
  .button { background: red;}
  .button:hover { background: blue;}
  .button.is-active { background: green;}
						</code></pre>
						<aside class="notes">
							<p>In Sass, the ampersand (&) symbol is used to reference the parent selector in a nested rule.</p>
						</aside>
					</section>


					<section data-state="full-code">
						<pre><code class="scss">
  // SCSS
  .button {
	color: $white;
	.nav & { color: $black; }
  }

  /* OUTPUT */
  .button { color: white; }
  .nav .button { color: black; }
						</code></pre>
						<aside class="notes">
							<p>The & can also be placed after a selector to reverse the nesting order</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>
  // SCSS
  $header-font: "Adelle";
  $fallback-font: "Cambria", "Georgia";

  h1, h2, h3, h4, h5, h6 {
	font-family: $header-font;
	.wf-inactive &,
	.lt-ie9 & {
	  font-family: $fallback-font;
	}
  }

  /* OUTPUT */
  h1, h2 { font-family: "Adelle"; }

  .wf-inactive h1, .lt-ie9 h1, .wf-inactive h2, .lt-ie9 h2 {
	font-family: "Cambria", "Georgia";
  }
						</code></pre>
						<aside class="notes">
							<p>This comes in really handy for things like Modernizr</p>
							<p>"Have you used Modernizr? What about the google web-font loader? At the very least you’ve used the trick from HTML5 Boilerplate to target versions of IE with some well-placed conditional comments? What do all of these have in common? They all dynamically, in one form or another, add classes to the root html class. In Modernizr’s case it tells you what features you can hook into within your CSS. In Google’s web-font loader it will update some classes in to tell us if and when our typefaces are loading or have loaded. This is where that ampersand has made things easier for me."</p>
							<p>http://www.joeloliveira.com/2011/06/28/the-ampersand-a-killer-sass-feature/</p>
						</aside>
					</section>

					<section>
						<h2>State Classes</h2>
					</section>

					<section data-state="full-code">
						<pre><code>
  // Buttons
  .button {
	&.is-active { background: red; color: white; }
  }

  // Nav Links
  .nav-link {
	&.is-active { color: green; }
  }

  /* OUTPUT */
  .button.is-active {
	background: red;
	color: white;
  }

  .nav-link.is-active {
	color: green;
  }

						</code></pre>
						<aside class="notes">
							<p>I like SMACSS style state classes; you can use nesting and the ampersand to namespace them so you can use something like .is-active in a lot of different styles and locations.</p>
						</aside>
					</section>

					<section>
						<h2>Namespacing Modules</h2>
						<aside class="notes">
							<p>Nesting CAN be used to namespace modules, and it can be VERY helpful in this regard. But <b>THINK</b> about what you are namespacing.</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>
  // NAV STYLES
  .nav { width: 50%; }

  .nav-item {
	display: inline-block;

	&:active,
	&:visited {
	  color: $purple;
	}
	&:hover {
	  color: $blue;
	  border-bottom: 3px solid $blue;
	}
	&.is-active {
	  color: $blue;
	  border-bottom: 3px solid $blue-dark;
	}
  }

							</code></pre>
						<aside class="notes">
							<p>Here's a simple example; you want the header nav colors to be different than the footer nav colors, but nothing else—margin, padding, etc, should all be the same.</p>
							<p>So here, you style the nav that will all be the same...</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>
  // HEADER
  .header {
	nav { float: right; }
  }

  // FOOTER
  .footer {
	background: $grey-dark;

	nav { float: left; }

	.nav-item {

	  &:active,
	  &:visited {
		color: $white;
	  }
	  &:hover {
		color: $blue-light;
		border-bottom: 3px solid $blue-light;
	  }
	  &.is-active {
		color: $blue-light;
		border-bottom: 3px solid $blue-light;
	  }
	}
  }

						</code></pre>
						<aside class="notes">
							<p>And then you can namespace inside the header and footer</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>
  .header nav { float: right; }

  .footer { background: #333; }
  .footer nav { float: left; }

  .footer .nav-item,
  .footer .nav-item:active,
  .footer .nav-item:visited {
	color: #fff;
  }

  .footer .nav-item:hover {
	color: #3a8bef;
	border-bottom: 3px solid #3a8bef;
  }

  .footer .nav-item.is-active {
	color: #3a8bef;
	border-bottom: 3px solid #0f59b4;
  }

							</code></pre>
						<aside class="notes">
							<p>And then your output is something like this</p>
							<p>Example from: http://thesassway.com/beginner/the-inception-rule</p>
						</aside>
					</section>

					<section>
						<div><p class="quote" style="font-size: 1.5em;">@includes duplicates CSS</p>> use when you need to alter variables</div><br/><br/>
						<div><p class="quote" style="font-size: 1.5em;">@extend comma-delineates selectors</p>> reuse code with no extra output</div><br/><br/>
						<aside class="notes">
							<p>@extend is an easy way for one selector to share the styles of another selector, without duplicating the lines of CSS in your output</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  // SCSS

  @mixin box {
	color: $white;
	background: $darkgrey;
	padding: $unit/2;
  }

  // Usage
  .box { @include box; }
  .widget { @include box; }
  .sprocket { @include box; }
						</code>
						</pre>
					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  /* OUTPUT */

  .box {
	color: #ffffff;
	background: #222222;
	padding: 10px;
  }
  .widget {
	color: #ffffff;
	background: #222222;
	padding: 10px;
  }
  .sprocket {
	color: #ffffff;
	background: #222222;
	padding: 10px;
  }
						</code>
						</pre>
						<aside class="notes">
							<p>You can imagine how this piles up...</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  // SCSS
  .box {
	color: $white;
	background: $darkgrey;
	padding: $unit/2;
  }

  .widget { @extend .box; }
  .sprocket { @extend .box; }


  /* OUTPUT */
  .box, .widget, .sprocket {
	color: #ffffff;
	background: #222222;
	padding: 10px;
  }
						</code>
						</pre>
						<aside class="notes">
							<p>Where mixins use @include and literally include the lines of code everywhere you write @include, @extend's output comma-delineates the classes. Instead the same 4 lines of CSS duplicated 3x, we have 4 lines.</p>
							<p>But note that we have defined .box as a class, so in our output, .box is there.</p>
							<a href="http://codepen.io/elyseholladay/pen/CyEqs">http://codepen.io/elyseholladay/pen/CyEqs</a>
						</aside>
					</section>

					<section>
						<h3>%placeholder</h3>
						<p>%placeholder extend takes this one step further, and eliminates the output for the original ruleset.</p>

						<aside class="notes">
							<p>[read before slide] Sometimes you’ll write styles for a class that you only ever want to @extend, and never want to use directly in your HTML. For our box styles, if that's visual only and the class .box never appears in our HTML, why output it into our CSS if it will never get applied? If you use normal classes and use @extend for this, you end up creating a lot of extra CSS when the stylesheets are generated. [now read slide]</p>
						</aside>

					</section>

					<section data-state="full-code">
						<pre>
						<code class="scss">
  // SCSS
  %box {
	color: $white;
	background: $darkgrey;
	padding: $unit/2;
  }

  .widget { @extend %box; }
  .sprocket { @extend %box; }


  /* OUTPUT */
  .widget, .sprocket {
	color: #ffffff;
	background: #222222;
	padding: 10px;
  }
						</code>
						</pre>
						<aside class="notes">
							<p>So here you can see it's just removed class .box from the output. Not a major decrease here but if you do this a lot, then you will see much less clutter in your CSS. This is especially helpful for visual helpers, like typography classes; I use it for named sizes and a "meta" style, which is ~20-40 lines of code in my CSS that I can eliminate with placeholders. Again, not a HUGE amount of file size.. but less junk. And when you are writing a BIG project, it adds up.</p>
							<p>more: http://css-tricks.com/the-extend-concept/</p>
						</aside>
					</section>


					<section>
						<h2>%clearfix</h2>
					</section>

					<section data-state="full-code">
						<pre><code>
  // Clearfix placeholder extend, won't compile unless used
  %clearfix {
	&:after {
	  content: "";
	  display: table;
	  clear: both;
	}
  }

  .wrap {
	width: 80%;
	// @extend %clearfix; // won't compile
  }

  .main-header {
	@extend %clearfix; // will compile
  }
						</code></pre>
						<aside class="notes">
							<p>In the past I've used a mixin for the clearfix, but as we know, that includes that clearfix code everywhere you include it.</p>
							<p>Instead, let's try using the placeholder––or silent class––selector.  This will concatenate all the selectors that you use it on AND this way nothing gets compiled to CSS unless we actually use it. This might not be best for ENORMOUS apps, but it's definitely less output.</p>
						</aside>
					</section>

					<section data-state="full-code">
						<pre><code>

  /* OUTPUT */
  .main-header:after {
	content: "";
	display: table;
	clear: both;
  }

  .wrap {
	width: 80%;
  }
						</code></pre>
					</section>

					<section>
						<p>where do you put new modules</p>
						<p>create new folder structure when you outgrow it</p>
					</section>

					<!-- namespacing / nesting leads to bloat -->
					<section data-state="badcomputer gifs">
						<aside class="notes">
							<p>You get bloated output when you write bad CSS, when you nest when you don't need to, or when you over-use mixins or extends that aren't necessary. <b>Read your output!</b> YOU as an author are responsible for the output of your code, the exact same way as you are when you write plain CSS. </p>
							<p>Also, in terms of performance and reducing size to the browser, you'll do FAR more by reducing your JS and images than you will reducing your CSS selectors.</p>
							<p>"As a general rule, your average stylesheet will increase by ~3k for every 100 lines of uncompressed code. The single ~700-line Sass-generated CSS file for this site — warts and all (i.e., repeated code blocks) — is ~22k uncompressed; minified and compressed: 4k. Even if I inadvertently added another 1300 lines of wasted code on top of this, bringing the file to 2000 lines, the minified and compressed version would still only be about 5k." http://atomeye.com/sass-and-compass.html</p>
						</aside>
					</section>

				</section>

				<section data-state="cya-module-refactor">
					<section>
						<h2>Steps to refactor a module</h2>
						<p>Goal: take your modules and do the actual refactor work!</p>

						<aside class="notes">
							<p>Our <em>files</em> are a bit easier to read now, but what's in those files may still be clunky and messy. We'll still be getting the bugs we were before, have classnames that need to be cleaned up, etc. So let's talk about refactoring that actually changes your CSS, and maybe even HTML.</p>
						</aside>
					</section>

					<section data-state="digg">
						<br><br><br>
						<h5>Chris Eppstein, "Refactor My Stylesheets: The Digg.com Edition"</h5>
						<aside class="notes">
							<p>Chris Eppstein, a Sass author, did a refactor of Digg's Feedback/voting stylesheet to see how they could benefit from Sass. This was in 2010—and he mentions a few features Sass didn't have then, like placeholder extend, that they do now that could improve on this even more.</p>

							<a href="http://chriseppstein.github.io/blog/2010/05/25/refactor-my-stylesheets-digg-edition/">link</a>
						</aside>
					</section>

					<section>
						<h5>Steps to Refactor</h5>
						<ol>
							<li>Extract partial</li>
							<li>Find repeating patterns</li>
							<li>Create/extract base class</li>
							<li>Apply nesting</li>
							<li>Create mixins/extends</li>
						</ol>
					</section>

					<section>
						<h3>Extract partial</h3>
						<p>"I cut the related styles and pasted them into a new partial stylesheet named <code>_feedback.scss</code>. Then I inserted <code>@import "feedback";</code> in its place in <code>global.scss</code>. Now I was able to focus on a single set of related styles."</p>
					</section>

					<section>
						<h3>Find repeating patterns</h3>
						<p>"...a large amount of selector duplication that implied an inheritance relationship, ...a repeating pattern relating to the colors and iconography, ...[and] some complex nesting of selectors."</p>
						<aside class="notes">
						<p>"There is a lot of duplication in CSS when you use semantic markup. It can be challenging to identify the different types of duplication. First and foremost, I saw a large amount of selector duplication that implied an inheritance relationship. I looked for a CSS class that could function as the base class and found none. I also saw a repeating pattern relating to the colors and iconography. Lastly, there was some complex nesting of selectors."</p>
						</aside>
					</section>
					<section>
						<h3>Create/extract base class</h3>
						<p>"I decided to call it <code>.feedback</code> because all of the class names in use described a type of user feedback and this class was not in use already."</p>
						<aside class="notes">
							here is where he says "Unfortunately, Sass does not yet have any notion of an abstract base class, so this cleanup will incur some cost of additional output of a style they don’t want or need." which is exactly what placeholder extend is.
						</aside>
					</section>

					<section>
						<h3>Apply nesting</h3>
						<p>"Much of the duplication required when styling semantic content is due to styling nested content. ... I’m using Sass’s parent-reference selector <code>&</code> with the styles for h3, strong."</p>
						<aside class="notes">
							<p>"Much of the duplication required when styling semantic content is due to styling nested content. Sass’s ability to nest selectors makes this stylesheet much easier to read and understand what’s going on. Note how I’m using Sass’s parent-reference selector (&) with the styles for h3, strong. The intent of that block is to style those elements, so I have inverted the nesting order to give more clarity to the intent of those styles."</p>
						</aside>
					</section>

					<section>
						<h3>Create mixins/extends</h3>
						<p>"The last major source of duplication ... is the common styling pattern for colors and iconography. To simplify this we extract a mixin and apply it wherever the pattern is in use."</p>
					</section>

					<section>
					<h5>Results?</h5>
					<h2 class="fragment">125 lines > 85 lines</h2>
						<aside class="notes">
							"85 lines of code... down from 125 lines of code and providing the exact same output... a 32% reduction!"
							<p>"But the biggest win is that adding a new kind of feedback requires only 1 or 2 points of edit instead of the 5-7 that would have been required before. This is, without a doubt, more maintainable...</p>
							<p>Then he says,"Additionally, we fixed six bugs without trying." "the defect rate in this tested, in-production stylesheet is evidence of how hard it is for even great front-end developers to maintain semantic CSS."</p>
						</aside>
					</section>

					<section>
						<p>determining the size of a refactor</p>
					</section>

				</section>

				<section data-state="cya-classname-refactor">
					<section>
						<h2>Refactoring both HTML and CSS</h2>
						<p>Goal: Determine how to refactor messy HTML.</p>
					</section>

					<section>
						<p>elements -> classnames</p>
					</section>

				</section>

				<section data-state="cya-naming-conventions">
					<section>
						<h2>Naming Conventions</h2>
						<p>Goal: Choose a naming convention that works for you.</p>
					</section>

					<section>
						<p>whatever you do, be consistent: .section, .section-item, .section-item-individualthingy</p>
					</section>

					<section>
						<p>OOCSS</p>
					</section>

					<section>
						<p>BEM</p>
					</section>

					<section>
						<p>SMACSS</p>
					</section>

					<section>
						<p>pros and cons of naming convention standards</p>
					</section>

					<section>
						<p>how to iterate on naming conventions and change them</p>
					</section>

					<section>
						<p>organizing properties (alpha, properties, camelcase vs underscore vs dash, etc)</p>
					</section>

				</section>

				<section data-state="cya-styleguides">
					<section>
						<h2>CYA: living style guides</h2>
					</section>

					<section>
						<p>docco, kss, etc, an overview of what they are</p>
					</section>

					<section>
						<p>vs manual creation</p>
					</section>

					<section>
						<p>show example of comments in sass file w/ relevant HTML & generate one)</p>
					</section>

				</section>

				<section data-state="cya-documentation">
					<section>
						<h2>Documentation & Commenting</h2>
						<p>Goal: have a consistent comment style and use it!</p>
					</section>

					<section data-state="comments">
						<li>Comment each file to explain what is in it</li>
						<li>Comment every large section of CSS</li>
						<li>Comment individual items that need clarification</li>
						<li>Be consistent</li>
						<aside class="notes">
							<p>Imagine the next person who inherits your codebase. Your comments should be a guide for them through your CSS. Especially with potentially confusing Sass variables and mixins, it's not enough to have a comment that says "This is a mixin for a CSS3 gradient with eighteen arguments". Better to also add instructions on how to use. If you have a style guide or wiki docs, reference that page/section as well!</p>
						</aside>
					</section>

					<section>
						<p>commenting files</p>
					</section>

					<section>
						<p>inline comment documentation; keep it up to date when you change your code.</p>
					</section>

					<section>
						<p>commenting imports</p>
					</section>

					<section>
						<p>commenting sections</p>
					</section>

					<section>
						<p>documentation/instructions</p>
					</section>

					<section data-state="full-code">
					<pre><code class="no-highlight">
// Single-line JS-style comments don't need a closing tag,
// and they are hidden from your compiled output! This is
// great for inline documentation about the styles themselves
// and how they should be used, mentioning hacks, or TODOs.

/* CSS style comments can be multi-line with a closing tag
   and they appear in your compiled output. This is great for
   section documentation and headers/dividers! */
					</code></pre>

						<aside class="notes">
							<p>In Sass, the JS style single-line comments with the two slashes are hidden from your output, which is great, because you can do a ton of commenting without anything showing up.</p>

							<p>However, there are occasions where you may WANT your comments to show up in your compiled CSS—recently I was trying to do this so that I could see where imported files began and ended in my output. Helpfully, the CSS style slash-asterisk comments DO show up in output! Handy!</p>
						</aside>
					</section>

					<section>
						<p>if you move files, change classnames that are referenced elsewhere</p>
					</section>

					<section>
						<p>if you make or change a mixin or helper, explain it, write instructions</p>
					</section>

					<section>
						<p>instructions for using mixins and extends</p>
					</section>
				</section>

				<section data-state="cya-testing">
					<section>
						<h2>Testing</h2>
						<p>Goal: Don't be breaking shit.</p>
					</section>

					<section>
						<p>how to test for changes/things that are broken after a refactor</p>
					</section>

					<section>
						<p>diffux, phantom, wraith</p>
						<p>https://github.com/klamping/UIRegression/blob/master/exercises/1-Wraith.md</p>
					</section>

					<section>
						<p>keeping refactors small so they don't break things</p>
					</section>

				</section>

				<section data-state="cya-myproject">
					<section>
						<h2>CYA: what's right for my project</h2>
					</section>

					<section>
						<p>how to tell what works for you</p>
					</section>

					<section>
						<p>naming conventions - why one would work better than another FOR your project</p>
					</section>

					<section>
						<p>organization of files/folders</p>
					</section>

					<section>
						<p>using elements vs classnames, BEM, OOCSS, etc</p>
					</section>

					<section>
						<p>using frameworks or not</p>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
